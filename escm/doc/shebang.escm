<?xml version="1.0"?><!-- -*- xml -*- -->
<!DOCTYPE html
     PUBLIC  "-//W3C//DTD XHTML 1.1//EN"
     "DTD/xhtml11-flat.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja">
  <head>
    <title>Notes on the shebang line</title>
    <meta http-equiv="Content-Type" content="text/html" />
    <link href="aescm.css" type="text/css" rel="stylesheet" />
    <?xml-stylesheet type="text/css" href="aescm.css"?>
    <!-- $Id$ -->
  </head>
<?scm
  (load "./helper.scm")
  (load "./config.scm")
  (define package-titlecase (string-titlecase PACKAGE))
?>
  <body>
    <h1>Note on the shebang line</h1>
    <address><a href="mailto:tagga@tsuda.ac.jp">TAGA Yoshitaka</a>
</address>

    <p>This document is a personal note on
treatment of the shebang line.
It will be too complex to implement without a tidy design.
So I make a note before modifying the code.</p>

    <h2>What is the problem?</h2>

    <p><em>Escm</em> is a filter tool. So the first line must be processed.
But it is also a frontend to interpreters.
So the first <q>#!</q> line must be parsed but not processed.</p>

    <p>What makes the problem complicated is the difference
of option parsing between in a command line and in a shebang line.
In a shebang line, seeming options and arguments are collected
and parsed as the optional first argument. So we must invoke
<em>escm</em> when we use <samp>-i</samp> option as:
</p>

    <blockquote>
      <pre>
escm -i "stklos -q"
but not
#!/usr/bin/escm -i "stklos -q"

#!/usr/bin/escm -i stklos -q
but not
escm -i stklos -q
</pre>
    </blockquote>

    <p>In general, suppose we have a script named <em>script</em>
whose first line is like this:</p>
    <blockquote>
      <pre>#!/usr/bin/intrepreter iarg1 iarg2</pre>
    </blockquote>
    <p>When we invoke <em>script</em> like this:</p>
    <blockquote>
      <pre>script oarg1 oarg2</pre>
    </blockquote>
    <p>Then for <em>interpreter</em> this invocation is equivalent to:</p>
    <blockquote>
      <pre>/usr/bin/interpreter "iarg1 iarg2" script oarg1 oarg2</pre>
    </blockquote>

    <h2>Solutions</h2>
    <h3>\</h3>
    <p>One solution is to move arguments to the second line and
parse them by itself. Kawai-san told me <em>scsh</em> adaptes this syntax.
</p>
    <blockquote>
      <pre>
#!/usr/bin/escm \
-i "interpreter -option"
 </pre>
    </blockquote>

    <p>Though I've never used this syntax,
it charmed me as a script programmer.
But as a C programmer, it seems to be a nightmare.
</p>
    <ul>
      <li>We cannot call <em>getopt()</em> till we have opened the first
file.</li>
      <li>We have to tokenize the option line by ourselves.</li>
      <li>We must move out of the preprocessor the part for skipping
the shebang line.  This means we need a mechanism to push back two
characters to the input stream, while our beloved <em>ungetc()</em>'s
limit is one.</li>
    </ul>
    <p>So what I have to do are:</p>
    <ul>
      <li><p>Cut off <em>skip_shebang()</em> from <em>preproc_common</em>.
</p></li>
      <li><p>Add an argument to <em>preproc_common()</em> in order to
recieve a character from <em>skip_shebang()</em>.</p></li>
      <li><p>Make a wrapper function of <em>getopt()</em>.</p></li>
      <li><p>Divide <em>escm_main()</em> into several functions.</p></li>
      <li><p>Make a function to incorporate the arguments in the option line
into <em>argv[]</em>.</p></li>
    </ul>

    <h3>#?</h3>
    <p>I've eliminated this syntax because of the second and third reasons.
As I wrote <q>parse.c</q>, what remains is the third one.
But I decided to adapt the metaswitch. It is not an obstacle any more.
I'll implement it.</p>

    <h3>-!</h3>
    <p>My own idea is to introduce a new option to show the argument
must be tokenized. With this, we can call <em>getopt()</em> at the right
place and need not to open any file before deciding what to do.
I think it is ideologically correct, but it wll never be popular
for esthetic reasons.
</p>

<?scm (footer)?>
  </body>
</html>
